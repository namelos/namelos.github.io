<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/component---src-templates-post-js-bd41ec710cf6e1dcb1d1.js" as="script"/><link rel="preload" href="/path---lambda-let-binding-and-module-dd5275fe7066e9e2071b.js" as="script"/><link rel="preload" href="/app-6fef5e29fce639328d0d.js" as="script"/><link rel="preload" href="/commons-677a0f8e0293361e4134.js" as="script"/><style id="gatsby-inlined-css">body{font-size:14px;font-family:Palatino,Palatino Linotype,Palatino LT STD,Book Antiqua,Georgia,SimSun,serif;background-color:#fffff8;color:#111;width:70%;max-width:1024px;margin:0 auto;overflow-x:hidden}@media (max-width:1023px){body{width:96%}}h1,h2,h3{font-weight:400;line-height:1.2;font-style:italic}h1{font-size:2.2rem;margin-top:4rem}h1,h2{margin-bottom:0}h2{font-size:1.7rem;margin-top:2.1rem}h3{font-size:1.5rem;margin-top:2rem;margin-bottom:0}div,ol,ul{font-size:1rem}div,ol,p,ul{line-height:2rem}div,p{margin-top:1.2rem;margin-bottom:1.2rem;padding-right:0;vertical-align:baseline}blockquote,div,p{font-size:1.2rem}code{font-family:Courier,Consolas,Liberation Mono,Menlo,Hiragino Sans GB,Microsoft YaHei,SimHei,monospace;font-size:1rem;line-height:1.42rem}pre{margin-left:40px;margin-right:40px}blockquote,pre.verse{color:#444;font-size:1.4rem;width:55%;margin-right:40px;font-style:italic;font-family:Palatino,Palatino Linotype,Palatino LT STD,Book Antiqua,Georgia,SimSun,serif}li{margin-top:.25rem}strong{font-style:italic}a:link,a:visited{color:inherit}a:link{text-decoration:none;background:linear-gradient(#fffff8,#fffff8),linear-gradient(#fffff8,#fffff8),linear-gradient(#333,#333);background-size:.05em 1px,.05em 1px,1px 1px;background-repeat:no-repeat,no-repeat,repeat-x;text-shadow:.03em 0 #fffff8,-.03em 0 #fffff8,0 .03em #fffff8,0 -.03em #fffff8,.06em 0 #fffff8,-.06em 0 #fffff8,.09em 0 #fffff8,-.09em 0 #fffff8,.12em 0 #fffff8,-.12em 0 #fffff8,.15em 0 #fffff8,-.15em 0 #fffff8;background-position:0 93%,100% 93%,0 93%}a:link::-moz-selection{text-shadow:.03em 0 #b4d5fe,-.03em 0 #b4d5fe,0 .03em #b4d5fe,0 -.03em #b4d5fe,.06em 0 #b4d5fe,-.06em 0 #b4d5fe,.09em 0 #b4d5fe,-.09em 0 #b4d5fe,.12em 0 #b4d5fe,-.12em 0 #b4d5fe,.15em 0 #b4d5fe,-.15em 0 #b4d5fe;background:#b4d5fe}a:link::selection{text-shadow:.03em 0 #b4d5fe,-.03em 0 #b4d5fe,0 .03em #b4d5fe,0 -.03em #b4d5fe,.06em 0 #b4d5fe,-.06em 0 #b4d5fe,.09em 0 #b4d5fe,-.09em 0 #b4d5fe,.12em 0 #b4d5fe,-.12em 0 #b4d5fe,.15em 0 #b4d5fe,-.15em 0 #b4d5fe;background:#b4d5fe}hr{display:block;height:1px;width:55%;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}img{max-width:100%}table{font-family:Trebuchet MS,Gill Sans,Gill Sans MT,Hiragino Sans GB,Microsoft YaHei,SimHei,sans-serif;overflow-x:auto;margin-left:40px;margin-right:40px}</style></head><body><div id="___gatsby"><div data-reactroot=""><div><h1><a href="/">Namelos</a> / <!-- -->Functional Programming, Lambda, Let Binding and Environments</h1><br/><small>2018-10-09</small><div><div>Functional programming language always tend to be simpler on mental model. In most of imperative languages, the design are usually more fragiled compared to functional languages.</div><div>One example could be variable bindings, let bindings and lambda.</div><div class="section"><h1>Lambda, Curried Functions and Lazy Evaluation</h1><div>Let start with lambda:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>This basically gives you back an anonymous function which does a increment. You can give it a name with special form <code>define</code>:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">increment</span> x<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>This is just short for:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> increment
  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>Let's see a function with larger arity:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">add</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>Similarily, this is actually:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> add
  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>Sadly, scheme function does not do auto currying, or we can have:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> add
  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>We need an extra pair of parentheses to invoke the nested version of <code>add</code>, but it simpified the lambda and function only to be 1-arity. This is what Haskell do. And another thing Haskell enabled by default is lazy evaluation, which fully made this language a "functional" programming language, since in haskell:</div><pre><code class="language-haskell"><span class="token hvariable">one</span> <span class="token operator">=</span> <span class="token number">1</span></code></pre><div>is basically in scheme:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> one
  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>dont-care<span class="token punctuation">)</span>
    <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>This is interesting because it not only consider n-arity functions are special case of 1-arity functions, but also variables or bindings are also a special case of 1-arity functions. Thus variables could be eliminated and replaced by function. But this idiom usually makes more sense for lazy language.</div></div><div class="section"><h1>Binding</h1><div>Then Let's consider binding:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">x</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">y</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>This bind <code>1</code> to <code>x</code> and bind <code>2</code> to <code>y</code>, but actually it's still a syntax sugar of lambda:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token number">1</span><span class="token punctuation">)</span>
 <span class="token number">2</span><span class="token punctuation">)</span></code></pre></div><div class="section"><h1>Variables</h1><div>The variable refering here is more like constants in imperative programming:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> x <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> y <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>increment<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>As long as we don't mutate <code>x</code> and <code>y</code>. Wherever you execute <code>increment</code> yields same result, even if there are other definition of <code>x</code> and <code>y</code> there. This is called <i>lexical closure</i>. And The fundemental concept under this is called <i>lexical scope</i> which basically means the environment of function can refer is the place it was created. This makes more sense because when people define it they mostly think about the code around the function.</div><div>Other kind of design also exist like <i>dynamic scope</i>, it means the function environment is dynamically defined by the execution environment, which could be a little bit faster but does not make sense nowadays since it's very confusing.</div><div>So it's like an environment which also bind to function context, instead a function is just itself without accessing any thing outside. This is tremendously useful because at least you need to refer other functions:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">square</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-of-squares</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">square</span> x<span class="token punctuation">)</span>
     <span class="token punctuation">(</span><span class="token function">square</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>Since we need to refer function anyway, this is a universal way to refer both functions and variables. However, other design also exists like Java cannot have first level value and functions. This is very disturbing, making people harder to refer things. Meanwhile, they still need to implement lexical scope in the language anyway. Other example is Lisp-2 like Common Lisp, the variable and function does not use same namespace, also makeing the mental model more complicated compared to scheme. But like dynamic scoping, those design decisions are also give you benefit of performance while damaging the power and accesibility of the language itself.</div></div><div class="section"><h1>Environments</h1><div>So what's an environment? Different langugage has different implementations, but it's more easier to understand environment in terms of lambda. And this is also a functional language design should try to implement.</div><div>Just keep thinking this:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> x <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> y <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>increment<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>As this:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> increment
  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>Things like rebind variable like this:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> x <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> y <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> x <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>increment<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>Could be think as function argument <i>shadowing</i>:</div><pre><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> increment
  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span>
         <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
           <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token number">2</span><span class="token punctuation">)</span>
   <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div>If a language design follows this idiom, things and details could be more concisely understandable.</div></div></div></div></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-6fef5e29fce639328d0d.js","195351340454287":"component---src-templates-post-js-bd41ec710cf6e1dcb1d1.js","35783957827783":"component---src-pages-index-js-c9d0abba2b4b8c2a6417.js","132761184526123":"path---common-lisp-1-a4551446ed865884c17c.js","141830964309527":"path---sicp-1-22c766c8bd58c1f5083f.js","273302927040515":"path---sicp-0-968f3a6ca87563c641da.js","198341299720095":"path---lambda-let-binding-and-module-dd5275fe7066e9e2071b.js","93501619469393":"path---sicp-ch-1-a2cf77029f68b4a81d2f.js","9339818220304":"path---sicp-exercise-ch-3-2102c65245a8e79f425c.js","243524056326353":"path---sicp-3-2-1757296c6bc911dbcc8c.js","245939732109026":"path---sicp-2-1-f833854a951e9c611f18.js","43846261805915":"path---sicp-ch-2-b90c8c7069cc04b37d66.js","104189591922118":"path---common-lisp-0-691f0dd69c1781674384.js","170072518859038":"path---sicp-3-3-ab0bc692f9962e1189ec.js","54858438791056":"path---kubernetes-9d7ec2da2e4437869d13.js","78168251461804":"path---fp-introduction-29efed1aefcc76d90ce2.js","142629428675168":"path---index-130a9ab36db9da9da8e1.js"}/*]]>*/</script><script>/*<![CDATA[*/["/commons-677a0f8e0293361e4134.js","/app-6fef5e29fce639328d0d.js","/path---lambda-let-binding-and-module-dd5275fe7066e9e2071b.js","/component---src-templates-post-js-bd41ec710cf6e1dcb1d1.js"].forEach(function(s){document.write('<script src="'+s+'" defer></'+'script>')})/*]]>*/</script></body></html>