{"version":3,"sources":["webpack:///path---common-lisp-1-6f51a545a3366fb35b6e.js","webpack:///./.cache/json/common-lisp-1.json"],"names":["webpackJsonp","220","module","exports","data","orga","html","meta","title","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,KAAA,s0KAAynKC,MAA4TC,MAAA,0CAAAC,KAAA,gBAAwEC,aAAgBC,KAAA","file":"path---common-lisp-1-6f51a545a3366fb35b6e.js","sourcesContent":["webpackJsonp([132761184526123],{\n\n/***/ 220:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"orga\":{\"html\":\"<div class=\\\"section\\\"><h1>Overview</h1><div>These are just random notes and comments during reading the great book about CL -- <i>Practical Common Lisp</i>. And this is some notes from the first chapter.</div></div><div class=\\\"section\\\"><h1>Functions</h1><div>Functional programming langugage is about functions, though CL is not just about functional programming. Thus define a function:</div><pre><code class=\\\"language-lisp\\\">(defun hello-world() (format t \\\"hello, world\\\"))</code></pre><div>And this is how to invoke it:</div><pre><code class=\\\"language-lisp\\\">(hello-world)</code></pre></div><div class=\\\"section\\\"><h1>Lists</h1><div>At its core, lisp is about list:</div><pre><code class=\\\"language-lisp\\\">(list 1 2 3)\\n(list :a 1 :b 2 :c 3)</code></pre><div>Lists with symbols (keywords start with :) are named <i>property list</i>, and <i>plist</i> for short.</div><div>Use <code>getf</code> to resolve values from plists.</div><pre><code class=\\\"language-lisp\\\">(getf (list :a 1 :b 2 :c 3) :a) ; => 1\\n(getf (list :a 1 :b 2 :c 3) :c) ; => 3</code></pre><div>Let's define a function returns a list</div><pre><code class=\\\"language-lisp\\\">(defun make-cd (title artist rating ripped)\\n  (list :title title :artist artist :rating rating :ripped ripped))\\n\\n(make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t)</code></pre></div><div class=\\\"section\\\"><h1>Variables and Mutations</h1><div><code>defvar</code> macro is used for define a global variable, and conventionally with asterisks around its name. And the <code>push</code> macro is straighfoward enough.</div><pre><code class=\\\"language-lisp\\\">(defvar *db* nil)\\n\\n(defun add-record (cd)\\n  (push cd *db*))\\n\\n(add-record (make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t))\\n(add-record (make-cd \\\"Fly\\\" \\\"Dixie Chicks\\\" 8 t))\\n(add-record (make-cd \\\"Home\\\" \\\"Dixie Chicks\\\" 9 t))</code></pre><div>To inspect the variable is just as simple as to type its name:</div><pre><code class=\\\"language-lisp\\\">*db*</code></pre><div>Use format to make the result more readable:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (dolist (cd *db*)\\n    (format t \\\"~{~a:~10t~a~%~}~%\\\" cd)))\\n\\n(dump-db)</code></pre><div><code>Format</code> accept two arguments: The first one is the stream it sends to, and t is short for the stream =*standard-output*=; The Second argument is both the literal and the formating directives.</div><div>Directives starts with <code>~</code> (similar to <code>printf</code>'s <code>%</code>). And <code>~a</code> is the <i>asthetic</i> directive which consumes one argument and output in a human-readable form. For keywords:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a\\\" :title) ; prints => TITLE</code></pre><div><code>~t</code> is for tabulating. <code>~10t</code> is tabulating 10 spaces:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a:~10t~a\\\" :artist \\\"Dixie Chicks\\\")</code></pre><div><code>~{</code> and <code>~}</code> is for starting and ending loop. The <code>~%</code> indicates a new line.</div><div><code>FORMAT</code> can also loop the <code>*db*</code> variable itslef:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (format t \\\"~{~{~a:~10t~a~%~}~%~}\\\" *db*))</code></pre></div><div class=\\\"section\\\"><h1>Promping and Reading Lines</h1><div><code>FORCE-OUTPUT</code> is to ensure lisp does not wait for new line. <code>READ-LINE</code> is to read string and <code>*query-io*</code> is a stream contains the input stream.</div><pre><code class=\\\"language-lisp\\\">(defun prompt-read (prompt)\\n  (format *query-io* \\\"~a: \\\" prompt)\\n  (force-output *query-io*)\\n  (read-line *query-io*))</code></pre><div>Then read with this function:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (prompt-read \\\"Rating\\\")\\n   (prompt-read \\\"Ripped [y/n]\\\")))</code></pre><div>Add parsing and fallback to rating, and make ripped options only accepts valid inputs:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (or (parse-integer (prompt-read \\\"Rating\\\") :junk-allowed t) 0)\\n   (y-or-n-p \\\"Ripped [y/n]: \\\")))</code></pre><div>Let user add more:</div><pre><code class=\\\"language-lisp\\\">(defun add-cds ()\\n  (loop (add-record (prompt-for-cd))\\n        (if (not (y-or-n-p \\\"Another? [y/n]: \\\")) (return))))</code></pre></div><div class=\\\"section\\\"><h1>Persistence</h1><div>To persist variable in file:</div><pre><code class=\\\"language-lisp\\\">(defun save-db (filename)\\n  (with-open-file (out filename\\n                       :direction :output\\n                       :if-exists :supersede)\\n    (with-standard-io-syntax\\n      (print *db* out))))\\n\\n(save-db \\\"~/my-cds.db\\\")</code></pre><div>Then read back:</div><pre><code class=\\\"language-lisp\\\">(defun load-db (filename)\\n  (with-open-file (in filename)\\n    (with-standard-io-syntax\\n      (setf *db (read in)))))</code></pre></div><div class=\\\"section\\\"><h1>Querying</h1><div>First let's see something like filtering:</div><pre><code class=\\\"language-lisp\\\">(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)\\n(remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)</code></pre><div>Then apply this pattern to our <strong>db</strong>:</div><pre><code class=\\\"language-lisp\\\">(defun select-by-artist (artist)\\n  (remove-if-not\\n   #'(lambda (cd)\\n       (equal (getf cd :artist) artist))\\n   *db*))\\n\\n(select-by-artist \\\"Dixie Chicks\\\")</code></pre></div>\",\"meta\":{\"title\":\"Practical Common Lisp Reading Notes (1)\",\"date\":\"2018-09-22\"}}},\"pathContext\":{\"slug\":\"/common-lisp-1/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---common-lisp-1-6f51a545a3366fb35b6e.js","module.exports = {\"data\":{\"orga\":{\"html\":\"<div class=\\\"section\\\"><h1>Overview</h1><div>These are just random notes and comments during reading the great book about CL -- <i>Practical Common Lisp</i>. And this is some notes from the first chapter.</div></div><div class=\\\"section\\\"><h1>Functions</h1><div>Functional programming langugage is about functions, though CL is not just about functional programming. Thus define a function:</div><pre><code class=\\\"language-lisp\\\">(defun hello-world() (format t \\\"hello, world\\\"))</code></pre><div>And this is how to invoke it:</div><pre><code class=\\\"language-lisp\\\">(hello-world)</code></pre></div><div class=\\\"section\\\"><h1>Lists</h1><div>At its core, lisp is about list:</div><pre><code class=\\\"language-lisp\\\">(list 1 2 3)\\n(list :a 1 :b 2 :c 3)</code></pre><div>Lists with symbols (keywords start with :) are named <i>property list</i>, and <i>plist</i> for short.</div><div>Use <code>getf</code> to resolve values from plists.</div><pre><code class=\\\"language-lisp\\\">(getf (list :a 1 :b 2 :c 3) :a) ; => 1\\n(getf (list :a 1 :b 2 :c 3) :c) ; => 3</code></pre><div>Let's define a function returns a list</div><pre><code class=\\\"language-lisp\\\">(defun make-cd (title artist rating ripped)\\n  (list :title title :artist artist :rating rating :ripped ripped))\\n\\n(make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t)</code></pre></div><div class=\\\"section\\\"><h1>Variables and Mutations</h1><div><code>defvar</code> macro is used for define a global variable, and conventionally with asterisks around its name. And the <code>push</code> macro is straighfoward enough.</div><pre><code class=\\\"language-lisp\\\">(defvar *db* nil)\\n\\n(defun add-record (cd)\\n  (push cd *db*))\\n\\n(add-record (make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t))\\n(add-record (make-cd \\\"Fly\\\" \\\"Dixie Chicks\\\" 8 t))\\n(add-record (make-cd \\\"Home\\\" \\\"Dixie Chicks\\\" 9 t))</code></pre><div>To inspect the variable is just as simple as to type its name:</div><pre><code class=\\\"language-lisp\\\">*db*</code></pre><div>Use format to make the result more readable:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (dolist (cd *db*)\\n    (format t \\\"~{~a:~10t~a~%~}~%\\\" cd)))\\n\\n(dump-db)</code></pre><div><code>Format</code> accept two arguments: The first one is the stream it sends to, and t is short for the stream =*standard-output*=; The Second argument is both the literal and the formating directives.</div><div>Directives starts with <code>~</code> (similar to <code>printf</code>'s <code>%</code>). And <code>~a</code> is the <i>asthetic</i> directive which consumes one argument and output in a human-readable form. For keywords:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a\\\" :title) ; prints => TITLE</code></pre><div><code>~t</code> is for tabulating. <code>~10t</code> is tabulating 10 spaces:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a:~10t~a\\\" :artist \\\"Dixie Chicks\\\")</code></pre><div><code>~{</code> and <code>~}</code> is for starting and ending loop. The <code>~%</code> indicates a new line.</div><div><code>FORMAT</code> can also loop the <code>*db*</code> variable itslef:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (format t \\\"~{~{~a:~10t~a~%~}~%~}\\\" *db*))</code></pre></div><div class=\\\"section\\\"><h1>Promping and Reading Lines</h1><div><code>FORCE-OUTPUT</code> is to ensure lisp does not wait for new line. <code>READ-LINE</code> is to read string and <code>*query-io*</code> is a stream contains the input stream.</div><pre><code class=\\\"language-lisp\\\">(defun prompt-read (prompt)\\n  (format *query-io* \\\"~a: \\\" prompt)\\n  (force-output *query-io*)\\n  (read-line *query-io*))</code></pre><div>Then read with this function:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (prompt-read \\\"Rating\\\")\\n   (prompt-read \\\"Ripped [y/n]\\\")))</code></pre><div>Add parsing and fallback to rating, and make ripped options only accepts valid inputs:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (or (parse-integer (prompt-read \\\"Rating\\\") :junk-allowed t) 0)\\n   (y-or-n-p \\\"Ripped [y/n]: \\\")))</code></pre><div>Let user add more:</div><pre><code class=\\\"language-lisp\\\">(defun add-cds ()\\n  (loop (add-record (prompt-for-cd))\\n        (if (not (y-or-n-p \\\"Another? [y/n]: \\\")) (return))))</code></pre></div><div class=\\\"section\\\"><h1>Persistence</h1><div>To persist variable in file:</div><pre><code class=\\\"language-lisp\\\">(defun save-db (filename)\\n  (with-open-file (out filename\\n                       :direction :output\\n                       :if-exists :supersede)\\n    (with-standard-io-syntax\\n      (print *db* out))))\\n\\n(save-db \\\"~/my-cds.db\\\")</code></pre><div>Then read back:</div><pre><code class=\\\"language-lisp\\\">(defun load-db (filename)\\n  (with-open-file (in filename)\\n    (with-standard-io-syntax\\n      (setf *db (read in)))))</code></pre></div><div class=\\\"section\\\"><h1>Querying</h1><div>First let's see something like filtering:</div><pre><code class=\\\"language-lisp\\\">(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)\\n(remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)</code></pre><div>Then apply this pattern to our <strong>db</strong>:</div><pre><code class=\\\"language-lisp\\\">(defun select-by-artist (artist)\\n  (remove-if-not\\n   #'(lambda (cd)\\n       (equal (getf cd :artist) artist))\\n   *db*))\\n\\n(select-by-artist \\\"Dixie Chicks\\\")</code></pre></div>\",\"meta\":{\"title\":\"Practical Common Lisp Reading Notes (1)\",\"date\":\"2018-09-22\"}}},\"pathContext\":{\"slug\":\"/common-lisp-1/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/common-lisp-1.json\n// module id = 220\n// module chunks = 132761184526123"],"sourceRoot":""}