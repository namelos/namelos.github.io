{"version":3,"sources":["webpack:///path---common-lisp-1-a4551446ed865884c17c.js","webpack:///./.cache/json/common-lisp-1.json"],"names":["webpackJsonp","229","module","exports","data","orga","html","meta","title","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,KAAA,q3PAAk5MC,MAAgmDC,MAAA,0CAAAC,KAAA,gBAAwEC,aAAgBC,KAAA","file":"path---common-lisp-1-a4551446ed865884c17c.js","sourcesContent":["webpackJsonp([132761184526123],{\n\n/***/ 229:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"orga\":{\"html\":\"<div class=\\\"section\\\"><h1>Overview</h1><div>These are just random notes and comments during reading the great book about CL -- <i>Practical Common Lisp</i>. And this is some notes from the first chapter. But the notes is not well writtened, just as a personal reminder.</div></div><div class=\\\"section\\\"><h1>Functions</h1><div>Functional programming langugage is about functions, though CL is not just about functional programming. Thus define a function:</div><pre><code class=\\\"language-lisp\\\">(defun hello-world() (format t \\\"hello, world\\\"))</code></pre><div>And this is how to invoke it:</div><pre><code class=\\\"language-lisp\\\">(hello-world)</code></pre></div><div class=\\\"section\\\"><h1>Lists</h1><div>At its core, lisp is about list:</div><pre><code class=\\\"language-lisp\\\">(list 1 2 3)\\n(list :a 1 :b 2 :c 3)</code></pre><div>Lists with symbols (keywords start with :) are named <i>property list</i>, and <i>plist</i> for short.</div><div>Use <code>getf</code> to resolve values from plists.</div><pre><code class=\\\"language-lisp\\\">(getf (list :a 1 :b 2 :c 3) :a) ; => 1\\n(getf (list :a 1 :b 2 :c 3) :c) ; => 3</code></pre><div>Let's define a function returns a list</div><pre><code class=\\\"language-lisp\\\">(defun make-cd (title artist rating ripped)\\n  (list :title title :artist artist :rating rating :ripped ripped))\\n\\n(make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t)</code></pre></div><div class=\\\"section\\\"><h1>Variables</h1><div><code>defvar</code> macro is used for define a global variable, and conventionally with asterisks around its name. And the <code>push</code> macro is straighfoward enough.</div><pre><code class=\\\"language-lisp\\\">(defvar *db* nil)\\n\\n(defun add-record (cd)\\n  (push cd *db*))\\n\\n(add-record (make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t))\\n(add-record (make-cd \\\"Fly\\\" \\\"Dixie Chicks\\\" 8 t))\\n(add-record (make-cd \\\"Home\\\" \\\"Dixie Chicks\\\" 9 t))</code></pre><div>To inspect the variable is just as simple as to type its name:</div><pre><code class=\\\"language-lisp\\\">*db*</code></pre><div>Use format to make the result more readable:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (dolist (cd *db*)\\n    (format t \\\"~{~a:~10t~a~%~}~%\\\" cd)))\\n\\n(dump-db)</code></pre><div><code>Format</code> accept two arguments: The first one is the stream it sends to, and t is short for the stream =*standard-output*=; The Second argument is both the literal and the formating directives.</div><div>Directives starts with <code>~</code> (similar to <code>printf</code>'s <code>%</code>). And <code>~a</code> is the <i>asthetic</i> directive which consumes one argument and output in a human-readable form. For keywords:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a\\\" :title) ; prints => TITLE</code></pre><div><code>~t</code> is for tabulating. <code>~10t</code> is tabulating 10 spaces:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a:~10t~a\\\" :artist \\\"Dixie Chicks\\\")</code></pre><div><code>~{</code> and <code>~}</code> is for starting and ending loop. The <code>~%</code> indicates a new line.</div><div><code>FORMAT</code> can also loop the <code>*db*</code> variable itslef:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (format t \\\"~{~{~a:~10t~a~%~}~%~}\\\" *db*))</code></pre></div><div class=\\\"section\\\"><h1>Promping and Reading Lines</h1><div><code>FORCE-OUTPUT</code> is to ensure lisp does not wait for new line. <code>READ-LINE</code> is to read string and <code>*query-io*</code> is a stream contains the input stream.</div><pre><code class=\\\"language-lisp\\\">(defun prompt-read (prompt)\\n  (format *query-io* \\\"~a: \\\" prompt)\\n  (force-output *query-io*)\\n  (read-line *query-io*))</code></pre><div>Then read with this function:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (prompt-read \\\"Rating\\\")\\n   (prompt-read \\\"Ripped [y/n]\\\")))</code></pre><div>Add parsing and fallback to rating, and make ripped options only accepts valid inputs:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (or (parse-integer (prompt-read \\\"Rating\\\") :junk-allowed t) 0)\\n   (y-or-n-p \\\"Ripped [y/n]: \\\")))</code></pre><div>Let user add more:</div><pre><code class=\\\"language-lisp\\\">(defun add-cds ()\\n  (loop (add-record (prompt-for-cd))\\n        (if (not (y-or-n-p \\\"Another? [y/n]: \\\")) (return))))</code></pre></div><div class=\\\"section\\\"><h1>Persistence</h1><div>To persist variable in file:</div><pre><code class=\\\"language-lisp\\\">(defun save-db (filename)\\n  (with-open-file (out filename\\n                       :direction :output\\n                       :if-exists :supersede)\\n    (with-standard-io-syntax\\n      (print *db* out))))\\n\\n(save-db \\\"~/my-cds.db\\\")</code></pre><div>Then read back:</div><pre><code class=\\\"language-lisp\\\">(defun load-db (filename)\\n  (with-open-file (in filename)\\n    (with-standard-io-syntax\\n      (setf *db (read in)))))</code></pre></div><div class=\\\"section\\\"><h1>Querying</h1><div>First let's see something like filtering:</div><pre><code class=\\\"language-lisp\\\">(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)\\n(remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)</code></pre><div>The notation ='#= means the following name indicates a function instead a variable. If we omit ='#= it will try to search a variable and fail. That's a core difference between Lisp-1 and Lisp-2. In Scheme or Clojure, functions and variables are in exact same namespace.</div><div>Then apply this pattern to our <strong>db</strong>:</div><pre><code class=\\\"language-lisp\\\">(defun select-by-artist (artist)\\n  (remove-if-not\\n   #'(lambda (cd)\\n       (equal (getf cd :artist) artist))\\n   *db*))\\n\\n(select-by-artist \\\"Dixie Chicks\\\")</code></pre><div>And generalize it a little bit:</div><pre><code class=\\\"language-lisp\\\">(defun select (selector-fn)\\n  (remove-if-not selector-fn *db*))\\n\\n(defun artist-selector (artist)\\n  #'(lambda (cd) (equal (getf cd :artist) artist)))\\n\\n(select (artist-selector \\\"Dixie Chicks\\\"))</code></pre></div><div class=\\\"section\\\"><h1>Argument List</h1><div>As we know, this function is 3 arity:</div><pre><code class=\\\"language-lisp\\\">(defun foo (a b c)\\n  (list a b c))\\n\\n(foo 1 2 3) ; => (1 2 3)</code></pre><div>This can help you use something similar as plist as arguments:</div><pre><code class=\\\"language-lisp\\\">(defun foo (&key a b c)\\n  (list a b c))\\n\\n(foo :a 1 :b 2 :c 3) ; => (1 2 3)</code></pre><div>Let define a <code>where</code> function with keyword list:</div><pre><code class=\\\"language-lisp\\\">(defun where (&key title artist rating (ripped nil ripped-p))\\n  #'(lambda (cd)\\n      (and\\n       (if title (equal (getf cd :title) title) t)\\n       (if artist (equal (getf cd :artist) artist) t)\\n       (if rating (equal (getf cd :rating) rating) t)\\n       (if ripped-p (equal (getf cd :ripped) ripped) t))))\\n\\n(select (where :artist \\\"Dixie Chicks\\\"))\\n(select (where :rating 10 :ripped nil))</code></pre><div>Note the ripped function is written as <code>(ripped nil ripped-p)</code>: If ripped is not provided by caller, it would fallback to the second element in list -- <code>nil</code>. In the meantime ripped-p would be nil, otherwise if caller provides the value it would be t. This helps you differenciate the argument is provided as nil or just absence.</div></div><div class=\\\"section\\\"><h1>Mutations</h1><div>Updating and deleting records:</div><pre><code class=\\\"language-lisp\\\">(defun update (selector-fn &key title artist rating (ripped nil ripped-p))\\n  (setf *db*\\n        (mapcar\\n         #'(lambda (row)\\n             (when (funcall selector-fn row)\\n               (if title (setf (getf row :title) title))\\n               (if artist (setf (getf row :artist) artist))\\n               (if rating (setf (getf row :rating) rating))\\n               (if ripped-p (setf (getf row :ripped) ripped)))\\n             row)\\n         *db*)))\\n\\n(defun delete-rows (selector-fn)\\n  (setf *db* (remove-if selector-fn *db*)))</code></pre></div><div class=\\\"section\\\"><h1></h1></div>\",\"meta\":{\"title\":\"Practical Common Lisp Reading Notes (1)\",\"date\":\"2018-09-22\"}}},\"pathContext\":{\"slug\":\"/common-lisp-1/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---common-lisp-1-a4551446ed865884c17c.js","module.exports = {\"data\":{\"orga\":{\"html\":\"<div class=\\\"section\\\"><h1>Overview</h1><div>These are just random notes and comments during reading the great book about CL -- <i>Practical Common Lisp</i>. And this is some notes from the first chapter. But the notes is not well writtened, just as a personal reminder.</div></div><div class=\\\"section\\\"><h1>Functions</h1><div>Functional programming langugage is about functions, though CL is not just about functional programming. Thus define a function:</div><pre><code class=\\\"language-lisp\\\">(defun hello-world() (format t \\\"hello, world\\\"))</code></pre><div>And this is how to invoke it:</div><pre><code class=\\\"language-lisp\\\">(hello-world)</code></pre></div><div class=\\\"section\\\"><h1>Lists</h1><div>At its core, lisp is about list:</div><pre><code class=\\\"language-lisp\\\">(list 1 2 3)\\n(list :a 1 :b 2 :c 3)</code></pre><div>Lists with symbols (keywords start with :) are named <i>property list</i>, and <i>plist</i> for short.</div><div>Use <code>getf</code> to resolve values from plists.</div><pre><code class=\\\"language-lisp\\\">(getf (list :a 1 :b 2 :c 3) :a) ; => 1\\n(getf (list :a 1 :b 2 :c 3) :c) ; => 3</code></pre><div>Let's define a function returns a list</div><pre><code class=\\\"language-lisp\\\">(defun make-cd (title artist rating ripped)\\n  (list :title title :artist artist :rating rating :ripped ripped))\\n\\n(make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t)</code></pre></div><div class=\\\"section\\\"><h1>Variables</h1><div><code>defvar</code> macro is used for define a global variable, and conventionally with asterisks around its name. And the <code>push</code> macro is straighfoward enough.</div><pre><code class=\\\"language-lisp\\\">(defvar *db* nil)\\n\\n(defun add-record (cd)\\n  (push cd *db*))\\n\\n(add-record (make-cd \\\"Roses\\\" \\\"Kathy Mattea\\\" 7 t))\\n(add-record (make-cd \\\"Fly\\\" \\\"Dixie Chicks\\\" 8 t))\\n(add-record (make-cd \\\"Home\\\" \\\"Dixie Chicks\\\" 9 t))</code></pre><div>To inspect the variable is just as simple as to type its name:</div><pre><code class=\\\"language-lisp\\\">*db*</code></pre><div>Use format to make the result more readable:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (dolist (cd *db*)\\n    (format t \\\"~{~a:~10t~a~%~}~%\\\" cd)))\\n\\n(dump-db)</code></pre><div><code>Format</code> accept two arguments: The first one is the stream it sends to, and t is short for the stream =*standard-output*=; The Second argument is both the literal and the formating directives.</div><div>Directives starts with <code>~</code> (similar to <code>printf</code>'s <code>%</code>). And <code>~a</code> is the <i>asthetic</i> directive which consumes one argument and output in a human-readable form. For keywords:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a\\\" :title) ; prints => TITLE</code></pre><div><code>~t</code> is for tabulating. <code>~10t</code> is tabulating 10 spaces:</div><pre><code class=\\\"language-lisp\\\">(format t \\\"~a:~10t~a\\\" :artist \\\"Dixie Chicks\\\")</code></pre><div><code>~{</code> and <code>~}</code> is for starting and ending loop. The <code>~%</code> indicates a new line.</div><div><code>FORMAT</code> can also loop the <code>*db*</code> variable itslef:</div><pre><code class=\\\"language-lisp\\\">(defun dump-db ()\\n  (format t \\\"~{~{~a:~10t~a~%~}~%~}\\\" *db*))</code></pre></div><div class=\\\"section\\\"><h1>Promping and Reading Lines</h1><div><code>FORCE-OUTPUT</code> is to ensure lisp does not wait for new line. <code>READ-LINE</code> is to read string and <code>*query-io*</code> is a stream contains the input stream.</div><pre><code class=\\\"language-lisp\\\">(defun prompt-read (prompt)\\n  (format *query-io* \\\"~a: \\\" prompt)\\n  (force-output *query-io*)\\n  (read-line *query-io*))</code></pre><div>Then read with this function:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (prompt-read \\\"Rating\\\")\\n   (prompt-read \\\"Ripped [y/n]\\\")))</code></pre><div>Add parsing and fallback to rating, and make ripped options only accepts valid inputs:</div><pre><code class=\\\"language-lisp\\\">(defun prompt-for-cd ()\\n  (make-cd\\n   (prompt-read \\\"Title\\\")\\n   (prompt-read \\\"Artist\\\")\\n   (or (parse-integer (prompt-read \\\"Rating\\\") :junk-allowed t) 0)\\n   (y-or-n-p \\\"Ripped [y/n]: \\\")))</code></pre><div>Let user add more:</div><pre><code class=\\\"language-lisp\\\">(defun add-cds ()\\n  (loop (add-record (prompt-for-cd))\\n        (if (not (y-or-n-p \\\"Another? [y/n]: \\\")) (return))))</code></pre></div><div class=\\\"section\\\"><h1>Persistence</h1><div>To persist variable in file:</div><pre><code class=\\\"language-lisp\\\">(defun save-db (filename)\\n  (with-open-file (out filename\\n                       :direction :output\\n                       :if-exists :supersede)\\n    (with-standard-io-syntax\\n      (print *db* out))))\\n\\n(save-db \\\"~/my-cds.db\\\")</code></pre><div>Then read back:</div><pre><code class=\\\"language-lisp\\\">(defun load-db (filename)\\n  (with-open-file (in filename)\\n    (with-standard-io-syntax\\n      (setf *db (read in)))))</code></pre></div><div class=\\\"section\\\"><h1>Querying</h1><div>First let's see something like filtering:</div><pre><code class=\\\"language-lisp\\\">(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)\\n(remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10)) ; => (2 4 6 8 10)</code></pre><div>The notation ='#= means the following name indicates a function instead a variable. If we omit ='#= it will try to search a variable and fail. That's a core difference between Lisp-1 and Lisp-2. In Scheme or Clojure, functions and variables are in exact same namespace.</div><div>Then apply this pattern to our <strong>db</strong>:</div><pre><code class=\\\"language-lisp\\\">(defun select-by-artist (artist)\\n  (remove-if-not\\n   #'(lambda (cd)\\n       (equal (getf cd :artist) artist))\\n   *db*))\\n\\n(select-by-artist \\\"Dixie Chicks\\\")</code></pre><div>And generalize it a little bit:</div><pre><code class=\\\"language-lisp\\\">(defun select (selector-fn)\\n  (remove-if-not selector-fn *db*))\\n\\n(defun artist-selector (artist)\\n  #'(lambda (cd) (equal (getf cd :artist) artist)))\\n\\n(select (artist-selector \\\"Dixie Chicks\\\"))</code></pre></div><div class=\\\"section\\\"><h1>Argument List</h1><div>As we know, this function is 3 arity:</div><pre><code class=\\\"language-lisp\\\">(defun foo (a b c)\\n  (list a b c))\\n\\n(foo 1 2 3) ; => (1 2 3)</code></pre><div>This can help you use something similar as plist as arguments:</div><pre><code class=\\\"language-lisp\\\">(defun foo (&key a b c)\\n  (list a b c))\\n\\n(foo :a 1 :b 2 :c 3) ; => (1 2 3)</code></pre><div>Let define a <code>where</code> function with keyword list:</div><pre><code class=\\\"language-lisp\\\">(defun where (&key title artist rating (ripped nil ripped-p))\\n  #'(lambda (cd)\\n      (and\\n       (if title (equal (getf cd :title) title) t)\\n       (if artist (equal (getf cd :artist) artist) t)\\n       (if rating (equal (getf cd :rating) rating) t)\\n       (if ripped-p (equal (getf cd :ripped) ripped) t))))\\n\\n(select (where :artist \\\"Dixie Chicks\\\"))\\n(select (where :rating 10 :ripped nil))</code></pre><div>Note the ripped function is written as <code>(ripped nil ripped-p)</code>: If ripped is not provided by caller, it would fallback to the second element in list -- <code>nil</code>. In the meantime ripped-p would be nil, otherwise if caller provides the value it would be t. This helps you differenciate the argument is provided as nil or just absence.</div></div><div class=\\\"section\\\"><h1>Mutations</h1><div>Updating and deleting records:</div><pre><code class=\\\"language-lisp\\\">(defun update (selector-fn &key title artist rating (ripped nil ripped-p))\\n  (setf *db*\\n        (mapcar\\n         #'(lambda (row)\\n             (when (funcall selector-fn row)\\n               (if title (setf (getf row :title) title))\\n               (if artist (setf (getf row :artist) artist))\\n               (if rating (setf (getf row :rating) rating))\\n               (if ripped-p (setf (getf row :ripped) ripped)))\\n             row)\\n         *db*)))\\n\\n(defun delete-rows (selector-fn)\\n  (setf *db* (remove-if selector-fn *db*)))</code></pre></div><div class=\\\"section\\\"><h1></h1></div>\",\"meta\":{\"title\":\"Practical Common Lisp Reading Notes (1)\",\"date\":\"2018-09-22\"}}},\"pathContext\":{\"slug\":\"/common-lisp-1/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/common-lisp-1.json\n// module id = 229\n// module chunks = 132761184526123"],"sourceRoot":""}